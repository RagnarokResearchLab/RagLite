local console = require("console")
local ffi = require("ffi")
local json = require("json")
local stbi = require("stbi")

local RagnarokTools = {}

local assert = assert
local math_floor = math.floor
local path_basename = path.basename
local path_extname = path.extname
local table_insert = table.insert

local RagnarokGND = require("Core.FileFormats.RagnarokGND")
local RagnarokGRF = require("Core.FileFormats.RagnarokGRF")
local RagnarokSPR = require("Core.FileFormats.RagnarokSPR")

function RagnarokTools:GenerateMapListFromGRF(grfFilePath)
	grfFilePath = grfFilePath or "data.grf"

	local grf = RagnarokGRF()
	grf:Open(grfFilePath)
	grf:Close()
	local fileList = grf:GetFileList()

	local completeMaps = {}
	local incompleteMaps = {}

	printf("Processing %d file entries ...", #fileList)

	for index, fileEntry in ipairs(fileList) do
		local extension = path_extname(fileEntry.name)
		local isRSW = (extension == ".rsw")

		if isRSW then
			local mapID = path_basename(fileEntry.name, ".rsw")

			local expectedGAT = "data/" .. mapID .. ".gat"
			local expectedGND = "data/" .. mapID .. ".gnd"

			local hasGAT = fileList[expectedGAT]
			local hasGND = fileList[expectedGND]

			if not hasGAT then
				printf("Pruned: %s (GAT file is missing)", mapID)
			end

			if not hasGND then
				printf("Pruned: %s (GND file is missing)", mapID)
			end

			if hasGAT and hasGND then
				table_insert(completeMaps, mapID)
			else
				table_insert(incompleteMaps, mapID)
			end
		end
	end

	printf("Finished processing %d maps (%d removed)", #completeMaps, #incompleteMaps)

	return completeMaps, incompleteMaps
end

function RagnarokTools:SaveMapDatabaseAsJSON(mapList, outputFilePath)
	outputFilePath = outputFilePath or "DB/maps-autogenerated.json"

	local jsonString = json.prettier(mapList)

	printf("Saving JSON-encoded map list to %s", outputFilePath)

	C_FileSystem.WriteFile(outputFilePath, jsonString)
end

function RagnarokTools:ExportLightmapsFromGND(gndFileContents)
	local gnd = RagnarokGND()
	gnd:DecodeFileContents(gndFileContents)

	console.startTimer("Lightmap Texture Generation")

	local textureImageWidth = gnd.gridSizeU * gnd.lightmapFormat.pixelWidth
	local textureImageHeight = gnd.gridSizeV * gnd.lightmapFormat.pixelHeight
	local shadowmapPixels = ffi.new("stbi_unsigned_char_t[?]", textureImageWidth * textureImageHeight * 4)
	local lightmapPixels = ffi.new("stbi_unsigned_char_t[?]", textureImageWidth * textureImageHeight * 4)

	for pixelV = 0, textureImageHeight - 1, 1 do
		for pixelU = 0, textureImageWidth - 1, 1 do
			local pixelIndex = pixelU + pixelV * textureImageWidth

			local gridU = math_floor(pixelU / gnd.lightmapFormat.pixelWidth)
			local gridV = math_floor(pixelV / gnd.lightmapFormat.pixelHeight)
			local cubeIndex = gridU + gnd.gridSizeU * gridV

			local cube = gnd.cubeGrid[cubeIndex]
			local surfaceTop = gnd.texturedSurfaces[cube.top_surface_id]
			assert(surfaceTop, "No TOP surface was assigned to the GND cube")
			local lightmapSlice = gnd.lightmapSlices[surfaceTop.lightmap_slice_id]
			assert(lightmapSlice, "No lightmap slice was assigned to the TOP surface")

			local texelU = pixelU % gnd.lightmapFormat.pixelWidth
			local texelV = pixelV % gnd.lightmapFormat.pixelHeight
			local texelID = texelU + texelV * gnd.lightmapFormat.pixelWidth

			assert(texelID <= 63, "Invalid texel ID (UV calculation must be wrong)")

			local OFFSET_RED, OFFSET_GREEN, OFFSET_BLUE, OFFSET_ALPHA = 0, 1, 2, 3
			local TEXEL_START_OFFSET = 3 * texelID
			local PIXEL_START_OFFSET = 4 * pixelIndex

			local opacity = lightmapSlice.ambient_occlusion_texels[texelID]
			local red = lightmapSlice.baked_lightmap_texels[TEXEL_START_OFFSET + OFFSET_RED]
			local green = lightmapSlice.baked_lightmap_texels[TEXEL_START_OFFSET + OFFSET_GREEN]
			local blue = lightmapSlice.baked_lightmap_texels[TEXEL_START_OFFSET + OFFSET_BLUE]

			shadowmapPixels[PIXEL_START_OFFSET + OFFSET_RED] = opacity
			shadowmapPixels[PIXEL_START_OFFSET + OFFSET_GREEN] = opacity
			shadowmapPixels[PIXEL_START_OFFSET + OFFSET_BLUE] = opacity
			shadowmapPixels[PIXEL_START_OFFSET + OFFSET_ALPHA] = 255

			lightmapPixels[PIXEL_START_OFFSET + OFFSET_RED] = red
			lightmapPixels[PIXEL_START_OFFSET + OFFSET_GREEN] = green
			lightmapPixels[PIXEL_START_OFFSET + OFFSET_BLUE] = blue
			lightmapPixels[PIXEL_START_OFFSET + OFFSET_ALPHA] = 255
		end
	end

	console.stopTimer("Lightmap Texture Generation")

	stbi.bindings.stbi_flip_vertically_on_write(true)

	self:ExportHumandReadableTextureImageAsPNG(shadowmapPixels, textureImageWidth, textureImageHeight, "shadowmap.png")
	self:ExportHumandReadableTextureImageAsPNG(lightmapPixels, textureImageWidth, textureImageHeight, "lightmap.png")

	stbi.bindings.stbi_flip_vertically_on_write(false)
end

function RagnarokTools:ExportHumandReadableTextureImageAsPNG(
	pixelBuffer,
	textureImageWidth,
	textureImageHeight,
	outputFileName
)
	local textureImage = ffi.new("stbi_image_t")
	textureImage.width = textureImageWidth
	textureImage.height = textureImageHeight
	textureImage.data = pixelBuffer
	textureImage.channels = 4 -- RGBA

	local maxFileSize = stbi.bindings.stbi_get_required_bmp_size(textureImage)
	local fileContents = buffer.new(maxFileSize)
	local startPointer, length = fileContents:reserve(maxFileSize)
	local numBytesWritten = stbi.bindings.stbi_encode_png(textureImage, startPointer, length, 0)

	assert(numBytesWritten > 0, "Failed to encode PNG contents")

	fileContents:commit(numBytesWritten)
	C_FileSystem.WriteFile(outputFileName, tostring(fileContents))
end

function RagnarokTools:ExportImagesFromSPR(sprFileContents, outputDirectory)
	outputDirectory = outputDirectory or "Exports"
	C_FileSystem.MakeDirectoryTree(outputDirectory)

	local spr = RagnarokSPR()
	spr:DecodeFileContents(sprFileContents)

	local palette = spr:GetEmbeddedColorPalette(sprFileContents)

	for index, image in ipairs(spr.bmpImages) do
		local indexedColorImageBytes = image.pixelBuffer
		local rgbaImageBytes = RagnarokSPR:ApplyColorPalette(indexedColorImageBytes, palette)
		local pngFileContents = C_ImageProcessing.EncodePNG(rgbaImageBytes, image.pixelWidth, image.pixelHeight)

		local pngFilePath = path.join(outputDirectory, format("bmp-frame-%d.png", index))
		C_FileSystem.WriteFile(pngFilePath, tostring(pngFileContents))
	end

	for index, image in ipairs(spr.tgaImages) do
		local pngFileContents = C_ImageProcessing.EncodePNG(image.pixelBuffer, image.pixelWidth, image.pixelHeight)

		local pngFilePath = path.join(outputDirectory, format("tga-frame-%d.png", index))
		C_FileSystem.WriteFile(pngFilePath, tostring(pngFileContents))
	end
end

return RagnarokTools
