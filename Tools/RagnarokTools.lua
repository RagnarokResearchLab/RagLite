local console = require("console")
local ffi = require("ffi")
local json = require("json")
local stbi = require("stbi")

local RagnarokTools = {}

local assert = assert
local math_floor = math.floor
local path_basename = path.basename
local path_extname = path.extname
local table_insert = table.insert

local BinaryReader = require("Core.FileFormats.BinaryReader")
local RagnarokGAT = require("Core.FileFormats.RagnarokGAT")
local RagnarokGND = require("Core.FileFormats.RagnarokGND")
local RagnarokGRF = require("Core.FileFormats.RagnarokGRF")
local RagnarokSPR = require("Core.FileFormats.RagnarokSPR")

local QuadTreeRange = require("Core.FileFormats.RSW.QuadTreeRange")

function RagnarokTools:GenerateMapListFromGRF(grfFilePath)
	grfFilePath = grfFilePath or "data.grf"

	local grf = RagnarokGRF()
	grf:Open(grfFilePath)
	grf:Close()
	local fileList = grf:GetFileList()

	local completeMaps = {}
	local incompleteMaps = {}

	printf("Processing %d file entries ...", #fileList)

	for index, fileEntry in ipairs(fileList) do
		local extension = path_extname(fileEntry.name)
		local isRSW = (extension == ".rsw")

		if isRSW then
			local mapID = path_basename(fileEntry.name, ".rsw")

			local expectedGAT = "data/" .. mapID .. ".gat"
			local expectedGND = "data/" .. mapID .. ".gnd"

			local hasGAT = fileList[expectedGAT]
			local hasGND = fileList[expectedGND]

			if not hasGAT then
				printf("Pruned: %s (GAT file is missing)", mapID)
			end

			if not hasGND then
				printf("Pruned: %s (GND file is missing)", mapID)
			end

			if hasGAT and hasGND then
				table_insert(completeMaps, mapID)
			else
				table_insert(incompleteMaps, mapID)
			end
		end
	end

	printf("Finished processing %d maps (%d removed)", #completeMaps, #incompleteMaps)

	return completeMaps, incompleteMaps
end

function RagnarokTools:SaveMapDatabaseAsJSON(mapList, outputFilePath)
	outputFilePath = outputFilePath or "DB/maps-autogenerated.json"

	local jsonString = json.prettier(mapList)

	printf("Saving JSON-encoded map list to %s", outputFilePath)

	C_FileSystem.WriteFile(outputFilePath, jsonString)
end

function RagnarokTools:ExportLightmapsFromGND(gndFileContents)
	local gnd = RagnarokGND()
	gnd:DecodeFileContents(gndFileContents)

	console.startTimer("Lightmap Texture Generation")

	local textureImageWidth = gnd.gridSizeU * gnd.lightmapFormat.pixelWidth
	local textureImageHeight = gnd.gridSizeV * gnd.lightmapFormat.pixelHeight
	local shadowmapPixels = ffi.new("stbi_unsigned_char_t[?]", textureImageWidth * textureImageHeight * 4)
	local lightmapPixels = ffi.new("stbi_unsigned_char_t[?]", textureImageWidth * textureImageHeight * 4)
	local combinedTextureImage = gnd:GenerateLightmapTextureImage()

	for pixelV = 0, textureImageHeight - 1, 1 do
		for pixelU = 0, textureImageWidth - 1, 1 do
			local pixelIndex = pixelU + pixelV * textureImageWidth

			local gridU = math_floor(pixelU / gnd.lightmapFormat.pixelWidth)
			local gridV = math_floor(pixelV / gnd.lightmapFormat.pixelHeight)
			local cubeIndex = gridU + gnd.gridSizeU * gridV

			local cube = gnd.cubeGrid[cubeIndex]
			local surfaceTop = gnd.texturedSurfaces[cube.top_surface_id]
			assert(surfaceTop, "No TOP surface was assigned to the GND cube")
			local lightmapSlice = gnd.lightmapSlices[surfaceTop.lightmap_slice_id]
			assert(lightmapSlice, "No lightmap slice was assigned to the TOP surface")

			local texelU = pixelU % gnd.lightmapFormat.pixelWidth
			local texelV = pixelV % gnd.lightmapFormat.pixelHeight
			local texelID = texelU + texelV * gnd.lightmapFormat.pixelWidth

			assert(texelID <= 63, "Invalid texel ID (UV calculation must be wrong)")

			local OFFSET_RED, OFFSET_GREEN, OFFSET_BLUE, OFFSET_ALPHA = 0, 1, 2, 3
			local TEXEL_START_OFFSET = 3 * texelID
			local PIXEL_START_OFFSET = 4 * pixelIndex

			local opacity = lightmapSlice.ambient_occlusion_texels[texelID]
			local red = lightmapSlice.baked_lightmap_texels[TEXEL_START_OFFSET + OFFSET_RED]
			local green = lightmapSlice.baked_lightmap_texels[TEXEL_START_OFFSET + OFFSET_GREEN]
			local blue = lightmapSlice.baked_lightmap_texels[TEXEL_START_OFFSET + OFFSET_BLUE]

			shadowmapPixels[PIXEL_START_OFFSET + OFFSET_RED] = opacity
			shadowmapPixels[PIXEL_START_OFFSET + OFFSET_GREEN] = opacity
			shadowmapPixels[PIXEL_START_OFFSET + OFFSET_BLUE] = opacity
			shadowmapPixels[PIXEL_START_OFFSET + OFFSET_ALPHA] = 255

			lightmapPixels[PIXEL_START_OFFSET + OFFSET_RED] = red
			lightmapPixels[PIXEL_START_OFFSET + OFFSET_GREEN] = green
			lightmapPixels[PIXEL_START_OFFSET + OFFSET_BLUE] = blue
			lightmapPixels[PIXEL_START_OFFSET + OFFSET_ALPHA] = 255
		end
	end

	console.stopTimer("Lightmap Texture Generation")

	stbi.bindings.stbi_flip_vertically_on_write(true)

	self:ExportHumandReadableTextureImageAsPNG(shadowmapPixels, textureImageWidth, textureImageHeight, "shadowmap.png")
	self:ExportHumandReadableTextureImageAsPNG(lightmapPixels, textureImageWidth, textureImageHeight, "lightmap.png")
	self:ExportHumandReadableTextureImageAsPNG(
		combinedTextureImage.rgbaImageBytes,
		combinedTextureImage.width,
		combinedTextureImage.height,
		"combined-lightmap-texture.png"
	)
	stbi.bindings.stbi_flip_vertically_on_write(false)
end

function RagnarokTools:ExportHumandReadableTextureImageAsPNG(
	pixelBuffer,
	textureImageWidth,
	textureImageHeight,
	outputFileName
)
	local textureImage = ffi.new("stbi_image_t")
	textureImage.width = textureImageWidth
	textureImage.height = textureImageHeight
	textureImage.data = pixelBuffer
	textureImage.channels = 4 -- RGBA

	local maxFileSize = stbi.bindings.stbi_get_required_bmp_size(textureImage)
	local fileContents = buffer.new(maxFileSize)
	local startPointer, length = fileContents:reserve(maxFileSize)
	local numBytesWritten = stbi.bindings.stbi_encode_png(textureImage, startPointer, length, 0)

	assert(numBytesWritten > 0, "Failed to encode PNG contents")

	fileContents:commit(numBytesWritten)
	C_FileSystem.WriteFile(outputFileName, tostring(fileContents))
end

function RagnarokTools:ExportImagesFromSPR(sprFileContents, outputDirectory)
	outputDirectory = outputDirectory or "Exports"
	C_FileSystem.MakeDirectoryTree(outputDirectory)

	local spr = RagnarokSPR()
	spr:DecodeFileContents(sprFileContents)

	local palette = spr:GetEmbeddedColorPalette(sprFileContents)

	for index, image in ipairs(spr.bmpImages) do
		local indexedColorImageBytes = image.pixelBuffer
		local rgbaImageBytes = RagnarokSPR:ApplyColorPalette(indexedColorImageBytes, palette)
		local pngFileContents = C_ImageProcessing.EncodePNG(rgbaImageBytes, image.pixelWidth, image.pixelHeight)

		local pngFilePath = path.join(outputDirectory, format("bmp-frame-%d.png", index))
		C_FileSystem.WriteFile(pngFilePath, tostring(pngFileContents))
	end

	for index, image in ipairs(spr.tgaImages) do
		local pngFileContents = C_ImageProcessing.EncodePNG(image.pixelBuffer, image.pixelWidth, image.pixelHeight)

		local pngFilePath = path.join(outputDirectory, format("tga-frame-%d.png", index))
		C_FileSystem.WriteFile(pngFilePath, tostring(pngFileContents))
	end
end

function RagnarokTools:ExportSceneGraphFromRSW(rswFileContents, outputDirectory)
	outputDirectory = outputDirectory or "Exports"
	local outputFilePath = path.posix.join(outputDirectory, "rsw-quadtree.bin")
	C_FileSystem.MakeDirectoryTree(outputDirectory)

	local reader = BinaryReader(rswFileContents)
	local quadTreeSize = QuadTreeRange:GetBinaryStorageSize()
	local offsetFromStartOfFile = #rswFileContents - quadTreeSize
	reader:Seek(offsetFromStartOfFile)
	local sceneGraph = QuadTreeRange(reader)

	local outputBufferSize = quadTreeSize
	local outputBuffer = buffer.new(outputBufferSize)
	printf(
		"[RagnarokTools] Reserved %s bytes (%s) of buffer space for quad tree ranges",
		outputBufferSize,
		string.filesize(outputBufferSize)
	)

	console.startTimer("Serializing bounding boxes")
	sceneGraph:RecursivelySerializeBoundingBoxes(outputBuffer)
	console.stopTimer("Serializing bounding boxes")

	printf("Writing %s bytes to %s ...", outputBufferSize, outputFilePath)
	C_FileSystem.WriteFile(outputFilePath, tostring(outputBuffer))

	-- Cairo can't render large images, but for a quick visual inspection this should be enough
	local dotFileContents = sceneGraph:ToGraphVizDot(2)
	C_FileSystem.WriteFile(outputFilePath .. ".dot", dotFileContents)
	printf("Generated GraphViz dot file: %s", outputFilePath .. ".dot")
	printf("To turn this into an actual diagram, install graphviz and then run the following command:")
	printf("dot -Tpng -o quadtree.png %s.dot", outputFilePath)
end

function RagnarokTools:ExportHeightMapFromGAT(gatFileContents, outputDirectory)
	outputDirectory = outputDirectory or "Exports"
	C_FileSystem.MakeDirectoryTree(outputDirectory)

	local gat = RagnarokGAT()
	gat:DecodeFileContents(gatFileContents)

	local rgbaImageBytes = buffer.new(gat.mapU * gat.mapV * 4)

	local maxObservedAltitude = 0
	for v = 1, gat.mapV do
		for u = 1, gat.mapU do
			local altitude = gat:GetTerrainAltitudeAt(u, v)
			maxObservedAltitude = math.max(maxObservedAltitude, altitude)
		end
	end

	local normalizationFactor = 1 - math.floor(255 / maxObservedAltitude)

	for v = 1, gat.mapV do
		for u = 1, gat.mapU do
			local altitude = gat:GetTerrainAltitudeAt(u, v)
			local relativeHeight = math.floor(altitude * normalizationFactor)
			rgbaImageBytes:putcdata(ffi.new("uint8_t[1]", relativeHeight * 255), 1)
			rgbaImageBytes:putcdata(ffi.new("uint8_t[1]", relativeHeight * 255), 1)
			rgbaImageBytes:putcdata(ffi.new("uint8_t[1]", relativeHeight * 255), 1)
			rgbaImageBytes:putcdata(ffi.new("uint8_t[1]", 0), 1)
		end
	end

	stbi.bindings.stbi_flip_vertically_on_write(true)
	local pngBytes = C_ImageProcessing.EncodePNG(rgbaImageBytes, gat.mapU, gat.mapV)
	stbi.bindings.stbi_flip_vertically_on_write(false)

	C_FileSystem.WriteFile(path.join(outputDirectory, "gat-height-map.png"), pngBytes)
end

function RagnarokTools:ExportCollisionMapFromGAT(gatFileContents, outputDirectory)
	outputDirectory = outputDirectory or "Exports"
	C_FileSystem.MakeDirectoryTree(outputDirectory)

	local gat = RagnarokGAT()
	gat:DecodeFileContents(gatFileContents)

	local rgbaImageBytes = buffer.new(gat.mapU * gat.mapV * 4)

	local maxObservedAltitude = 0
	for v = 1, gat.mapV do
		for u = 1, gat.mapU do
			local altitude = gat:GetTerrainAltitudeAt(u, v)
			maxObservedAltitude = math.max(maxObservedAltitude, altitude)
		end
	end

	for v = 1, gat.mapV do
		for u = 1, gat.mapU do
			local isBlocked = gat:IsObstructedTerrain(u, v)
			rgbaImageBytes:putcdata(ffi.new("uint8_t[1]", (isBlocked and 0 or 1) * 255), 1)
			rgbaImageBytes:putcdata(ffi.new("uint8_t[1]", (isBlocked and 0 or 1) * 255), 1)
			rgbaImageBytes:putcdata(ffi.new("uint8_t[1]", (isBlocked and 0 or 1) * 255), 1)
			rgbaImageBytes:putcdata(ffi.new("uint8_t[1]", 0), 1)
		end
	end

	stbi.bindings.stbi_flip_vertically_on_write(true)
	local pngBytes = C_ImageProcessing.EncodePNG(rgbaImageBytes, gat.mapU, gat.mapV)
	stbi.bindings.stbi_flip_vertically_on_write(false)

	C_FileSystem.WriteFile(path.join(outputDirectory, "gat-collision-map.png"), pngBytes)
end

local terrainTypeColors = {
	[0] = { red = 0xA5, blue = 0xBF, green = 0x65 },
	[1] = { red = 0, blue = 0, green = 0 },
	[2] = { red = 0x26, blue = 0x22, green = 0x4A },
	[3] = { red = 0x52, blue = 0x7F, green = 0x80 },
	[4] = { red = 0x4C, blue = 0x50, green = 0x73 },
	[5] = { red = 0xC1, blue = 0xC5, green = 0xB2 },
	[6] = { red = 0x3C, blue = 0x40, green = 0x2B },
	[7] = { red = 0xFF, blue = 0, green = 0xFF },
}

function RagnarokTools:ExportTerrainMapFromGAT(gatFileContents, outputDirectory)
	outputDirectory = outputDirectory or "Exports"
	C_FileSystem.MakeDirectoryTree(outputDirectory)

	local gat = RagnarokGAT()
	gat:DecodeFileContents(gatFileContents)

	local rgbaImageBytes = buffer.new(gat.mapU * gat.mapV * 4)

	local maxObservedAltitude = 0
	for v = 1, gat.mapV do
		for u = 1, gat.mapU do
			local altitude = gat:GetTerrainAltitudeAt(u, v)
			maxObservedAltitude = math.max(maxObservedAltitude, altitude)
		end
	end

	for v = 1, gat.mapV do
		for u = 1, gat.mapU do
			local tileID = gat:MapPositionToTileID(u, v)
			local terrainTypeID = tonumber(gat.collisionMap[tileID].terrain_flags)
			local pixelColor = terrainTypeColors[terrainTypeID]

			assert(pixelColor, format("Missing pixel color for terrain type %s", terrainTypeID))

			rgbaImageBytes:putcdata(ffi.new("uint8_t[1]", pixelColor.red), 1)
			rgbaImageBytes:putcdata(ffi.new("uint8_t[1]", pixelColor.green * 255), 1)
			rgbaImageBytes:putcdata(ffi.new("uint8_t[1]", pixelColor.blue * 255), 1)
			rgbaImageBytes:putcdata(ffi.new("uint8_t[1]", 0), 1)
		end
	end

	stbi.bindings.stbi_flip_vertically_on_write(true)
	local pngBytes = C_ImageProcessing.EncodePNG(rgbaImageBytes, gat.mapU, gat.mapV)
	stbi.bindings.stbi_flip_vertically_on_write(false)

	C_FileSystem.WriteFile(path.join(outputDirectory, "gat-terrain-map.png"), pngBytes)
end

return RagnarokTools
